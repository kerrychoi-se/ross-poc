import { NextRequest, NextResponse } from "next/server";
import { buildThreeQuarterPrompt } from "@/lib/prompts/three-quarter-prompt";

type ProductType = "wall-art" | "shelf";

export async function POST(request: NextRequest) {
  try {
    const { image, productType } = await request.json();

    if (!image) {
      return NextResponse.json({ error: "No image provided" }, { status: 400 });
    }

    if (!productType) {
      return NextResponse.json(
        { error: "No product type provided" },
        { status: 400 }
      );
    }

    // Validate product type
    if (productType !== "wall-art" && productType !== "shelf") {
      return NextResponse.json(
        { error: "Invalid product type. Must be 'wall-art' or 'shelf'" },
        { status: 400 }
      );
    }

    const apiKey = process.env.GEMINI_API_KEY?.trim();
    const model = process.env.GEMINI_MODEL || "gemini-3-pro-image-preview";
    const aspectRatio = process.env.GEMINI_ASPECT_RATIO || "1:1";
    const imageSize = process.env.GEMINI_IMAGE_SIZE || "2K";

    if (!apiKey) {
      return NextResponse.json(
        { error: "Gemini API key not configured" },
        { status: 500 }
      );
    }

    // Extract base64 data from data URL if present
    let base64Image = image;
    let mimeType = "image/png";

    if (image.includes(",")) {
      const parts = image.split(",");
      base64Image = parts[1];
      // Extract mime type from data URL
      const mimeMatch = parts[0].match(/data:([^;]+);/);
      if (mimeMatch) {
        mimeType = mimeMatch[1];
      }
    }

    // Build the 3/4 angle prompt for this product type
    const prompt = buildThreeQuarterPrompt(productType as ProductType);

    // Build the content parts array: prompt text + head-on reference image only.
    // The head-on image already encodes the full aesthetic (materials, lighting,
    // palette) so no additional reference images are needed.
    const contentParts: Array<
      | { text: string }
      | { inline_data: { mime_type: string; data: string } }
    > = [
      { text: prompt },
      {
        inline_data: {
          mime_type: mimeType,
          data: base64Image,
        },
      },
    ];

    // Call Gemini API with imageConfig for aspect ratio and resolution control
    const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

    const payload = {
      contents: [
        {
          parts: contentParts,
        },
      ],
      generationConfig: {
        responseModalities: ["TEXT", "IMAGE"],
        imageConfig: {
          aspectRatio,
          imageSize,
        },
      },
    };

    console.log(
      `[generate-three-quarter] Processing ${productType}, aspect ratio: ${aspectRatio}, image size: ${imageSize}`
    );

    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error("Gemini API error:", errorText);
      return NextResponse.json(
        { error: `Gemini API error: ${response.status}` },
        { status: response.status }
      );
    }

    const result = await response.json();

    // Extract the generated image from the response
    const candidates = result.candidates;
    if (!candidates || candidates.length === 0) {
      return NextResponse.json(
        { error: "No response from Gemini API" },
        { status: 500 }
      );
    }

    const parts = candidates[0].content?.parts;
    if (!parts || parts.length === 0) {
      return NextResponse.json(
        { error: "No content in Gemini response" },
        { status: 500 }
      );
    }

    // Find the final (non-thought) image part in the response.
    // Thinking mode produces interim images marked with "thought": true.
    // We want the last image part that is NOT a thought.
    const imageParts = parts.filter(
      (part: { inlineData?: { mimeType: string; data: string }; thought?: boolean }) =>
        part.inlineData?.mimeType?.startsWith("image/") && !part.thought
    );

    const imagePart = imageParts.length > 0 ? imageParts[imageParts.length - 1] : null;

    if (!imagePart?.inlineData) {
      // Check if there's a text response explaining why no image was generated
      const textPart = parts.find(
        (part: { text?: string }) => typeof part.text === "string"
      );
      if (textPart?.text) {
        console.error("Gemini text response (no image):", textPart.text);
      }
      return NextResponse.json(
        { error: "No image generated by Gemini" },
        { status: 500 }
      );
    }

    const generatedImage = `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`;

    return NextResponse.json({
      image: generatedImage,
    });
  } catch (error) {
    console.error("Generate three-quarter view error:", error);
    return NextResponse.json(
      { error: "Failed to generate 3/4 angle view" },
      { status: 500 }
    );
  }
}
